# Генерация трехадресного кода

Подробная документация по методами и классам есть в коде программы. Для
доступа необходимо навести указатель мыши (hover) над вызванным методом.
## Общая информация
 
Каждая строка трехадресного кода записана в формате `label: id = var1 op var2` (кроме специальных)

Для хранения строк различных типов присутствуют специализированные ноды,
наследники абстрактного класса **TacNode**, имеющего nullable-поле
`Label`, которое не равно `null` только в случае, если туда ведет ветвь
уловного/безусловного перехода. 

Также, он содержит поле `IsUtility`, которое обозначает, что данная нода
была сгенерирована в ходе парсинга if/while/for конструкций и не
является меткой, поставленной пользователем в коде программы;
используется только для внутренней реализации слияния меток.


Следует учесть, что при генерации трехадресного кода некоторых
конструкций могут создаваться пустые метки для операторов goto. Они
будут иметь `IsUtility == false` и существовать только в том случае,
если за ними не будет следовать строка кода. 

Из-за процесса слияния, метка выхода из цикла while, за которым следует
оператор присваивания, будет СОВМЕЩЕНА с этим оператором (см. Пример 3).


 
Каждое поле в нодах описано как строка типа **string**

1. **TacEmptyNode** (пустая строка с меткой или без нее `L1: `)
   1. Прямой наследник от TacNode для предоставления возможности инстанцирования
2. **TacGotoNode** (строка безусловного перехода `goto L2`) 
   1. Содержит целевую метку перехода `TargetLabel`
3. **TacIfGotoNode** (строка условного перехода `if t1 goto L2`)
   1. Содержит целевую метку перехода `TargetLabel`
   2. Содержит поле условия переходя `Condition`. Из-за особенностей
      реализации, поле ВСЕГДА является временной переменной `tn`,
      значение которой распарсено и присвоено строками ранее
4. **TacAssignmentNode** (строка присваивания `t1 = t2 + 1`)
   1. Содержит поле идентификатора временной переменной
      `LeftPartIdentifier`
   2. Содержит поле идентификатора первого операнда `FirsOperand`
   3. Содержит поле идентификатора второго операнда (nullable)
      `SecondOperand`
   4. Содержит поле операции (nullable) `Operation`
   
В качестве контейнера для трехадресного кода используется класс
**ThreeAddressCode**

Он написан на основе связного списка **LinkedList** (get-only поле
**TACodeLines**) с элементами типа **\<TacNode\>** и реализует интерфейс
**IEnumerable**

Он предоставляет следующий функционал:

1. Доступ к элементам на чтение и модификацию
   1. Доступ по метке с помощью оператора []
   1. Получение элемента по метке `label` в формате вызова метода
      `GetNodeByLabel` или при доступе через []
   2. Модификация или переприсваивание элемента по метке `label` в
      формате вызова метода `SetNodeByLabel` или при доступе через []
2. Модификация контейнера
   1. Добавление строки кода (нод) в конец списка `PushNode`
   2. Добавление нескольких строк кода (нод) в конец списка
      `PushNodes(IEnumerable)`
   3. Удаление ноды из списка `RemoveNode` 
   4. Удаление ноды из списка по метке `RemoveNodeByLabel`
   5. Удаление нескольких нод из списка `RemoveNodes(IEnumerable)`
3. Набор методов для удобства добавления тривиальных нод 
4. Поля First/Last для удобства получения соответствующих
   LinkedListNode<>

Для генерации имен временных переменных и меток используется класс
**TmpNameManager** 

Он реализует паттер синглтон, доступ к методам происходит через
статическое поле **Instance**

В нем заложен счетчик меток и переменных, для генерации нового имени
следует пользоваться методами

- TmpNameManager.Instance.GenerateTmpVariableName()
- TmpNameManager.Instance.GenerateTmpLabel()

Для генерации трехадресного кода используется визитор
**ThreeAddressCodeVisitor** 

В нем переопределены соответствующие методы для обхода AST и генерации
TAC для 

- Операторов присваивания (с обработкой тривиальных кейсов и логических
  операций)
- Циклов for и while
- Уловного опретора if-else

#### Пример 1: 
Из кода
```c# 
a = b + 1 
```
Будет сгенерирован TAC

```
t1 = b + 1
a = t1
```
#### Пример 2: 
Из кода 

```c# 
while (a == 0){
  a = 1;
}
```
Будет сгенерирован TAC

```
L1: t1 = a == 0
if t1 goto L3
goto L2
L3: a = 1
goto L1
L2:
```
#### Пример 3: 
Из кода 

```c# 
while (a == 0){
  a = 1;
}
a = b + 1;
```
Будет сгенерирован TAC

```
L1: t1 = a == 0
if t1 goto L3
goto L2
L3: a = 1
goto L1
L2: t2 = b + 1
a = t2
```

