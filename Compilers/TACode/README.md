# Генерация трехадресного кода

Подробная документация по методами и классам есть в коде программы. Для
доступа необходимо навести указатель мыши (hover) над вызванным методом.
## Общая информация
 
Каждая строка трехадресного кода записана в формате `label: id = var1 op var2` (кроме специальных)

Для хранения строк различных типов присутствуют специализированные ноды,
наследники абстрактного класса **TacNode**, имеющего лишь поле `Label`

Каждое поле в нодах описано как строка типа **string**

1. **TacEmptyNode** (пустая строка с меткой `L1: `)
   1. Прямой наследник от TacNode для предоставления возможности инстанцирования
2. **TacGotoNode** (строка безусловного перехода `L1: goto L2`) 
   1. Содержит целевую метку перехода `TargetLabel`
3. **TacIfGotoNode** (строка условного перехода `L1: if t1 goto L2`)
   1. Содержит целевую метку перехода `TargetLabel`
   2. Содержит поле условия переходя `Condition`
4. **TacAssignmentNode** (строка присваивания `L1: t1 = t2 + 1`)
   1. Содержит поле идентификатора временной переменной
      `LeftPartIdentifier`
   2. Содержит поле идентификатора первого операнда `FirsOperand`
   3. Содержит поле идентификатора второго операнда (nullable)
      `SecondOperand`
   4. Содержит поле операции (nullable) `Operation`
   
В качестве контейнера для трехадресного кода используется класс
**ThreeAddressCode**

Он написан на основе связного списка **LinkedList** (get-only поле
**TACodeLines**) с элементами типа **\<TacNode\>** и реализует интерфейс
**IEnumerable**

Он предоставляет следующий функционал:

1. Доступ к элементам на чтение и модификацию
   1. Доступ по метке с помощью оператора []
   1. Получение элемента по метке `label` в формате вызова метода
      `GetNodeByLabel` или при доступе через []
   2. Модификация или переприсваивание элемента по метке `label` в
      формате вызова метода `SetNodeByLabel` или при доступе через []
2. Модификация контейнера
   1. Добавление строки кода (нод) в конец списка `PushNode`
   2. Добавление нескольких строк кода (нод) в конец списка
      `PushNodes(IEnumerable)`
   3. Удаление ноды из списка `RemoveNode` 
   4. Удаление ноды из списка по метке `RemoveNodeByLabel`
   5. Удаление нескольких нод из списка `RemoveNodes(IEnumerable)`
3. Набор методов для удобства добавления тривиальных нод

Для генерации имен временных переменных и меток используется класс
**TmpNameManager** 

Он реализует паттер синглтон, доступ к методам происходит через
статическое поле **Instance**

В нем заложен счетчик меток и переменных, для генерации нового имени
следует пользоваться методами

- TmpNameManager.Instance.GenerateTmpVariableName()
- TmpNameManager.Instance.GenerateTmpLabel()

Для генерации трехадресного кода используется визитор
**ThreeAddressCodeVisitor** 

В нем переопределены соответствующие методы для обхода AST и генерации
TAC для 

- Операторов присваивания
- Циклов for и while
- Уловного опретора if-else

## Дополнительно
### Реализация некоторых моментов генерации TAC 

>  **При реализации циклов и условных переходов, в трехадресном коде
>  создается пустая метка, на которую будут вести соответствующие
>  переходы goto.**

#### Пример: 
Из кода
```c#
while (((a == 0) && (b != 1))) { 
    a = (a - 1); 
}
``` 
Будет сгенерирован TAC

```
L1:
L2: t1 = a == 0
L3: t2 = b != 1
L4: t3 = t1 && t2
L7: if t3 goto L6
L8: goto L5
L6:
L9: t4 = a - 1
L10: a = t4
L11: goto L1
L5:
```
L6, L5 и L1 в данном случае, являются метками для джампов goto

В презентациях пустой метки нет, сгенерированные goto ведут на метки, в
которых есть код.


>  **При разворачивании некоторых простых структур языка, TAC может быть
>  исчерпывающе длинным.**

#### Пример: 
Из кода 

```c# 
a = b + 1 
```
Будет сгенерирован TAC

```
L1: t1 = b
L2: t2 = 1
L3: t3 = t1 + t2
L4: a = t3
```

Для избежания подобного поведения в файле определения класса визитора
выставлен 

`#define SINGLE_TAC_ASSIGN_COMMANDS_REQUIRED` 

Убрать определение в
случае, если подобное поведение желательно.

#### Пример с define: 
Из кода 

```c# 
a = b + 1 
```
Будет сгенерирован TAC

```
L1: t1 = b + 1
L2: a = t1
```

Аналогичная ситуация наблюдается для условных выражений внутри while и
if-else

#### Пример: 
Из кода 

```c# 
while (a == 0){ // Интересует конкретно условие a == 0
  a = 1;
}
```
Будет сгенерирован TAC

```
L1: t1 = a
L2: t2 = 0
L3: t3 = t1 == t2
...
```
    
Для избежания подобного поведения в файле определения класса визитора
выставлен 

`#define SINGLE_TAC_EXPRESSION_COMMANDS_REQUIRED` 

#### Пример c define: 
Из кода 

```c# 
while (a == 0){ // Интересует конкретно условие a == 0
  a = 1;
}
```
Будет сгенерирован TAC

```
L1: t1 = a == 0
```
