# Введение

Было получено задание разработать оптимизирующий компилятор. В ходе разработки необходимо изучить разные подходы к оптимизации пользовательского кода. Первоначальными оптимизациями являются оптимизации AST дерева и трёхадресного кода. Эти оптимизации должны распределиться между всеми командами и в конечнном проекте запускаться каскадно. Необходима разработка системы выделения и хранения базовых блоков, а также графа потока управления. В процессе выполнения задачи нужно рассмотреть такие понятия как достигающие определения, активные переменные и доступные выражения, а также итерационные алгоритмы для каждого из них. Для структур потоков данных с использованием итеративного алгоритма требуются передаточные функции, а также их композиции. Для анализа потока данных используются полурешетки, с помощью которых естественным образом индуцируется отношение частичного порядка. Чтобы получить анализ графа потока управления необходимо вычислить доминаторы, построить глубинное остовное дерево, реализовать функцию по выявлению приводимого графа, а такжн классифицировать рёбра графа на три группы: наступающие, отступающие и поперечные. Для построения естественных циклов в графе потока управления требуется реализовать вычисление глубины графа. С помощью свойств естественных циклов можно реализовать измененный итерационный алгоритм.


# Cодержание
Список всех задач с гиперссылками:
1. [Парсер языка и построение AST-дерева](#Парсер-языка-и-построение-AST-дерева)
1. [Замена выражения вида 0 * expr, expr * 0 на 0.](#Замена-выражения-вида-0-*-expr,-expr-*-0-на-0.)
1. [Cвёртка констант в AST-дереве.](#Cвёртка-констант-в-AST-дереве.)
1. [Замена выражения вида 0 * expr, expr * 0 на 0.](#Замена-выражения-вида-0-*-expr,-expr-*-0-на-0.)
1. [Замена выражения вида 1 * expr, expr * 1, expr / 1 на expr.](#Замена-выражения-вида-1-*-expr,-expr-*-1,-expr-/-1-на-expr.)
1. [Замена выражений вида 2 < 3 на true (false)](#Замена-выражений-вида-2-<-3-на-true-(false))
1. [Оптимизация по дереву вида a > a, a != a](#Оптимизация-по-дереву-вида-a->-a,-a-!=-a)
1. [Замена выражения вида x = x на null.](#Замена-выражения-вида-x-=-x-на-null.)
1. [Замена if (true) st1; else st2; на st1.](#Замена-if-(true)-st1;-else-st2;-на-st1.)
1. [Замена выражения вида if (false) expr1 else expr2 на expr2.](#Замена-выражения-вида-if-(false)-expr1-else-expr2-на-expr2.)
1. [Замена выражений вида if (false) st1; else st2; на st2](#Замена-выражений-вида-if-(false)-st1;-else-st2;-на-st2)
1. [Удаление мертвых ветвлений.](#Удаление-мертвых-ветвлений.)
1. [Замена while (false) st; на null.](#Замена-while-(false)-st;-на-null.)
1. [Замена while (false) st; на null.](#Замена-while-(false)-st;-на-null.)
1. [Структура для представления трехадресного кода и его генерация.](#Структура-для-представления-трехадресного-кода-и-его-генерация.)
1. [Разбиение трёхадресного кода на базовые блоки.](#Разбиение-трёхадресного-кода-на-базовые-блоки.)
1. [Вычисление Def-Use в пределах базового блока.](#Вычисление-Def-Use-в-пределах-базового-блока.)

1. [Протяжка констант на основе Def-Use в пределах базового блока.](#Протяжка-констант-на-основе-Def-Use-в-пределах-базового-блока.)

1. [Протяжка копий на основе Def-Use в пределах базового блока.](#Протяжка-копий-на-основе-Def-Use-в-пределах-базового-блока.)
1. [Живые и мертвые переменные внутри ББЛ.](#Живые-и-мертвые-переменные-внутри-ББЛ.)

1. [Свёртка констант. Алгебраические тождества.](#Свёртка-констант.-Алгебраические-тождества.)

1. [Оптимизация логических тождеств.](#Оптимизация-логических-тождеств.)

1. [Оптимизация общих подвыражений и протяжка копий.](#Оптимизация-общих-подвыражений-и-протяжка-копий.)

2. [Очистка от пустых операторов, устранение переходов через переходы.](#Очистка-от-пустых-операторов,-устранение-переходов-через-переходы.)

1. [Устранение недостижимого кода.](#Устранение-недостижимого-кода.)

1. [Устранение переходов к переходам.](#Устранение-переходов-к-переходам)

1. [Local Value Numbering (LVN).](#Local-Value-Numbering-(LVN).)

1. [Разбиение CFG (Control FlowGraph).](#Разбиение-CFG-(Control-FlowGraph).)

1. [Достигающие определения - genB, killB.](#Достигающие-определения-genB,-killB.)

1. [Хранение IN-OUT.](#Хранение-IN-OUT.)

1. [Передаточная функция базового блока В (Вычисление путем композиции).](#Передаточная-функция-базового-блока-В-(Вычисление-путем-композиции).)

1. [Передаточная функция базового блока В (Вычисление путем применения явных формул).](#Передаточная-функция-базового-блока-В-(Вычисление-путем-применения-явных-формул).)

1. [Вычисление множеств def и use для активных переменных.](#Вычисление-множеств-def-и-use-для-активных-переменных.)

1. [Итерационный алгоритм для активных переменных.](#Итерационный-алгоритм-для-активных-переменных.)

1. [Протяжка const на основе итеративного алгоритма для достигающих определений.](#Протяжка-const-на-основе-итеративного-алгоритма-для-достигающих-определений.)

1. [Удаление мертвого кода на основе ИТА для активных переменных.](#Удаление-мертвого-кода-на-основе-ИТА-для-активных-переменных.)

1. [Итерационный алгоритм для достигающих определений.](#Итерационный-алгоритм-для-достигающих-определений.)

1. [Итерационный алгоритм для доступных выражений.](#Итерационный-алгоритм-для-доступных-выражений.)

1. [Провести оптимизации на основе анализа доступных выражений.](#Провести-оптимизации-на-основе-анализа-доступных-выражений.)

1. [Доступные выраж.-множества e_genB, e_killB. Передаточная ф-ия ББЛ в fB = e_genB U (x - e_killB).](#Доступные-выраж.-множества-e_genB,-e_killB.-Передаточная-ф-ия-ББЛ-в-fB-=-e_genB-U-(x-e_killB).)

1. [Общий класс для передаточной функции.](#Общий-класс-для-передаточной-функции.)

1. [Обобщённый итерационный алгоритм. Распространение констант.](#Обобщённый-итерационный-алгоритм.-Распространение-констант.)

1. [Оператор сбора /\ и отображение m в задаче о распространении констант.](#Оператор-сбора-/\-и-отображение-m-в-задаче-о-распространении-констант.)

1. [Поиск решения методом MOP.](#Поиск-решения-методом-MOP.)

1. [Построение дерева доминаторов.](#Построение-дерева-доминаторов.)

1. [Итерационный алгоритм для задачи распространения констант.](#Итерационный-алгоритм-для-задачи-распространения-констант.)

1. [Передаточная функция в задаче о распространении констант.](#Передаточная-функция-в-задаче-о-распространении-констант.)

1. [Классификация ребер в CFG.](#Классификация-ребер-в-CFG.)

1. [Определение глубины cfg.](#Определение-глубины-cfg.)

1. [Определение того, является ли ребро обратимым и является ли CFG приводимым.](#Определение-того,-является-ли-ребро-обратимым-и-является-ли-CFG-приводимым.
)
1. [Определение всех естественных циклов в CFG с информацией об их вложенности.](#Определение-всех-естественных-циклов-в-CFG-с-информацией-об-их-вложенности.)

1. [Построение глубинного остовного дерева с соответствующей нумерацией вершин.](#Построение-глубинного-остовного-дерева-с-соответствующей-нумерацией-вершин.)

1. [Ускорение итерационного алгоритма для задачи о достигающих определениях, засчет перенумерации базовых блоков.](#Ускорение-итерационного-алгоритма-для-задачи-о-достигающих-определениях,-засчет-перенумерации-базовых-блоков.)
