# Название задачи
Ускорение итерационного алгоритма для задачи о достигающих определениях засчет перенумерации базовых блоков

## Постановка задачи
Создать класс, реализующий ускорение итерационного алгоритма для 
задачи о достигающих определениях засчет перенумерации базовых блоков.

## Команда — исполнитель
"Null"

## Зависимости
Зависит от:
- DST
- Обобщенный итерационный алгоритм (ЗГ)
- Построение глубинного остовного дерева с соответствующей нумерацией вершин (Null)

## Теория

TODO

## Реализация
```
public class ReachingDefinitionsSortedITA : IterationAlgorithm<TacNode>
{
	public ReachingDefinitionsSortedITA(
			ControlFlowGraph cfg,
            Dictionary<ThreeAddressCode, IExpressionSetsContainer> lines
        ) : base(cfg.GetCFGWithSortedVertices(), new TFByComposition(lines), new UnionCollectionOperator<TacNode>())
	{
		Execute();
	}
}
```
## Тесты

INPUT:

```
if (a < 5)
     for (j = 1 to 10)
         a = a + 1;
 else
     if (a > 10)
         a = a - 10;
 p = 2;
```

OUTPUT:

```
OUT[0] = {0, 0}

IN[1] = {0, 0}
OUT[1] = {0, 0}
OUT[1] = {1, 0}

IN[2] = {0, 0}
IN[2] = {1, 0}
OUT[2] = {0, 0}
OUT[2] = {1, 0}

IN[3] = {0, 0}
IN[3] = {1, 0}
OUT[3] = {0, 0}
OUT[3] = {1, 0}
OUT[3] = {3, 0}
OUT[3] = {3, 1}

IN[4] = {0, 0}
IN[4] = {1, 0}
IN[4] = {3, 0}
IN[4] = {3, 1}
OUT[4] = {0, 0}
OUT[4] = {1, 0}
OUT[4] = {3, 0}
OUT[4] = {3, 1}

IN[5] = {0, 0}
OUT[5] = {0, 0}
OUT[5] = {5, 0}

IN[6] = {0, 0}
IN[6] = {5, 0}
IN[6] = {6, 0}
IN[6] = {6, 1}
IN[6] = {6, 2}
IN[6] = {6, 3}
OUT[6] = {0, 0}
OUT[6] = {6, 0}
OUT[6] = {6, 1}
OUT[6] = {6, 2}
OUT[6] = {6, 3}

IN[7] = {0, 0}
IN[7] = {1, 0}
IN[7] = {3, 0}
IN[7] = {3, 1}
IN[7] = {6, 0}
IN[7] = {6, 1}
IN[7] = {6, 2}
IN[7] = {6, 3}
OUT[7] = {0, 0}
OUT[7] = {1, 0}
OUT[7] = {3, 0}
OUT[7] = {3, 1}
OUT[7] = {6, 0}
OUT[7] = {6, 1}
OUT[7] = {6, 2}
OUT[7] = {6, 3}
OUT[7] = {7, 0}
```

## Вывод
Используя метод, описанные выше, мы смогли выполнить ускорение итерационного алгоритма для задачи о достигающих определениях засчет перенумерации базовых блоков