# Построение дерева доминаторов 

## Постановка задачи
Для Control-flow graph построить дерево доминаторов на основе итерационного алгоритма.

## Команда — исполнитель
AW

## Зависимости
Зависит от:
- Трехадресный код (AW)
- Разбиение на базовые блоки (Enterprise)
- Обобщенный ИТА (ЗГ)
- Хранение IN-OUT (AW)

## Теория
Пусть d, n &mdash; вершины Control-flow graph. Будем говорить, что d dom n
(d ***доминирует*** над n) если любой путь от входного узла к n проходит
через d.

Среди всех доминаторов узла будем выделять ***непосредственный
доминатор***: m idom n, обладающий следующими свойствами:
m dom n, m ≠ n и если d dom n, d ≠ n, то d dom m.

***Дерево доминаторов*** &mdash; вспомогательная структура данных, содержащая информацию об отношениях доминирования. 
При этом дуга от узла M к узлу N идет тогда и только тогда, когда M является непосредственным доминатором N.

![](../images/46-teamAW-1.PNG)

Примечание: здесь p - непосредственно предшествующие блоки.

## Реализация
Тут должно быть куски кода с объяснением. Самый большой раздел

Пример куска кода:
```csharp
using System;

foreach (var i in list)
    Console.WriteLine(i);
```

## Тесты
Узнать как должны выглядить тесты в докуметации.

## Вывод
Используя метод, описанные выше, было выполнено построение дерева доминаторов (всех и непосредственных) для Control-flow graph.

