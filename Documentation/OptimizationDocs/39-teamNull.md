# Название задачи
Итерационный алгоритм для достигающих определений.

## Постановка задачи
Реалзовать итерационный алгоритм для достигающих определений.

## Команда — исполнитель
"Null"

## Зависимости
Зависит от:
- Обобщенный ИТА (ЗГ)
- Генерация множеств gen и kill (Enterprise, Kt)
- Разбиение на базовые блоки (Enterprise)

## Теория
**Определение:** Будем говорить, что определение d достигает точки p,
если существует путь от точки, непосредственно следующей за d, к
точке p, такой, что d не уничтожается вдоль этого пути.
Анализ должен быть консервативным: если не знаем, есть ли другое
присваивание на пути, то считаем, что существует.

Достигающие определения используются при:
- Является ли x константой в точке p? (если p достигает одно
определение x, и это – определение константы)
- Является ли x в точке p неинициализированной? (если p не
достигает ни одно определение x)

Передаточная функция в общем случае для достигающих определений:
![](../images/39-teamNull-1.png)

Оператор сбора для достигающих определений:
![](../images/39-teamNull-2.png)

Уравнения для достигающих определений:
![](../images/39-teamNull-3.png)

Итеративный алгоритм:

**Вход:** граф потока управления, в котором для каждого ББл вычислены
*genB* и *killB*

**Выход:** Множества достигающих определений на входе *IN[B]* и на
выходе *OUT[B]* для каждого ББл B

![](../images/39-teamNull-4.png)

**Сходимость алгоритма:** на каждом шаге *IN[B]* и *OUT[B]* не
уменьшаются для всех B и ограничены сверху, поэтому алгоритм
сходится.

## Реализация
Алгоритм реализован в соответствии со схемой, приведенной выше.

```
public class ReachingDefinitionsITA : IterationAlgorithm<TacNode>
{
	public ReachingDefinitionsITA(
			ControlFlowGraph cfg,
			Dictionary<ThreeAddressCode, IExpressionSetsContainer> lines
			) : base(cfg, new TFByComposition(lines), new UnionCollectionOperator<TacNode>())
    {
        Execute();
	}
```
## Тесты

INPUT:

```
a = 1;
for (i = 1 to 10)
	for (j = 1 to 10)
		a = a + 1;
```
OUTPUT:

```
OUT[0] = {0, 0}
OUT[0] = {0, 1}

IN[1] = {0, 0}
IN[1] = {0, 1}
IN[1] = {2, 0}
IN[1] = {2, 1}
IN[1] = {2, 2}
IN[1] = {2, 3}
IN[1] = {3, 0}
IN[1] = {3, 1}
OUT[1] = {0, 0}
OUT[1] = {0, 1}
OUT[1] = {1, 0}
OUT[1] = {2, 0}
OUT[1] = {2, 1}
OUT[1] = {2, 3}
OUT[1] = {3, 0}
OUT[1] = {3, 1}

IN[2] = {0, 0}
IN[2] = {0, 1}
IN[2] = {1, 0}
IN[2] = {2, 0}
IN[2] = {2, 1}
IN[2] = {2, 2}
IN[2] = {2, 3}
IN[2] = {3, 0}
IN[2] = {3, 1}
OUT[2] = {0, 1}
OUT[2] = {2, 0}
OUT[2] = {2, 1}
OUT[2] = {2, 2}
OUT[2] = {2, 3}
OUT[2] = {3, 0}
OUT[2] = {3, 1}

IN[3] = {0, 1}
IN[3] = {2, 0}
IN[3] = {2, 1}
IN[3] = {2, 2}
IN[3] = {2, 3}
IN[3] = {3, 0}
IN[3] = {3, 1}
OUT[3] = {2, 0}
OUT[3] = {2, 1}
OUT[3] = {2, 2}
OUT[3] = {2, 3}
OUT[3] = {3, 0}
OUT[3] = {3, 1}
```

## Вывод
Используя метод, описанные выше, мы смогли реалзовать итерационный алгоритм для достигающих определений.