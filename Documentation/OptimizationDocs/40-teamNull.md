# Итерационный алгоритм для достигающих определений.

## Постановка задачи
Реалзовать итерационный алгоритм для достигающих определений.

## Команда — исполнитель
Null

## Зависимости
Зависит от:
- Обобщенный ИТА
- Генерация множеств gen и kill
- Разбиение на базовые блоки

## Теория
**Определение:** Будем говорить, что определение d достигает точки p,
если существует путь от точки, непосредственно следующей за d, к
точке p, такой, что d не уничтожается вдоль этого пути.
Анализ должен быть консервативным: если не знаем, есть ли другое
присваивание на пути, то считаем, что существует.

Достигающие определения используются при:
- Является ли x константой в точке p? (если p достигает одно
определение x, и это – определение константы)
- Является ли x в точке p неинициализированной? (если p не
достигает ни одно определение x)

Передаточная функция в общем случае для достигающих определений:
![](../images/39-teamNull-1.png)

Оператор сбора для достигающих определений:
![](../images/39-teamNull-2.png)

Уравнения для достигающих определений:
![](../images/39-teamNull-3.png)

Итеративный алгоритм:

**Вход:** граф потока управления, в котором для каждого ББл вычислены
*genB* и *killB*

**Выход:** Множества достигающих определений на входе *IN[B]* и на
выходе *OUT[B]* для каждого ББл B

![](../images/39-teamNull-4.png)

**Сходимость алгоритма:** на каждом шаге *IN[B]* и *OUT[B]* не
уменьшаются для всех B и ограничены сверху, поэтому алгоритм
сходится.

## Реализация
Алгоритм реализован в соответствии со схемой, приведенной выше.

```
public class ReachingDefinitionsITA : IterationAlgorithm<TacNode>
{
	public ReachingDefinitionsITA(
			ControlFlowGraph cfg,
			Dictionary<ThreeAddressCode, IExpressionSetsContainer> lines
			) : base(cfg, new TFByComposition(lines), new UnionCollectionOperator<TacNode>())
    {
        Execute();
	}
```
## Тесты

INPUT:

```
a = 1;
for (i = 1 to 10)
	for (j = 1 to 10)
		a = a + 1;
```
OUTPUT:

```

	#0:
0.0: a = 1  
0.1: i = 1  

	#1:
1.0: L1: j = 1  

	#2:
2.0: L2: t1 = a + 1
2.1: a = t1  
2.2: j = j + 1
2.3: t2 = j < 10
	    if t2 goto L2

	#3:
3.0: i = i + 1
3.1: t3 = i < 10
	    if t3 goto L1
		
Gen/Kill
		
Gen[0] = {0.0, 0,1}
Kill[0] = {2.1, 3.0}

Gen[1] = {1.0}
Kill[1] = {2.2}

Gen[2] = {2.0, 2.1, 2.2, 2.3}
Kill[2] = {0.0, 1.0}

Gen[3] = {3.0, 3,1}
Kill[3] = {2.1, 3.0}

IN/OUT

OUT[0] = {0.1}

IN[1] = {0.0, 0.1, 2.0, 2.1, 2.2, 2.3, 3.0, 3.1}
OUT[1] = {0.0, 0.1, 1.0, 2.0, 2.1, 2.3, 3.0, 3.1}


IN[2] = {0.0, 0.1, 1.0, 2.0, 2.1, 2.2, 2.3, 3.0,3.1}
OUT[2] = {0.1, 2.0, 2.1, 2.2, 2.3, 3.0, 3,1}


IN[3] = {0.1, 2.0, 2.1, 2.2, 2.3, 3.0, 3.1}
OUT[3] = {2.0, 2.1, 2.2, 2.3, 3.0, 3.1}
```
![](../images/39-teamNull-5.png)

## Вывод
Используя метод, описанные выше, мы смогли реалзовать итерационный алгоритм для достигающих определений.
