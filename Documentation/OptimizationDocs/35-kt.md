# Передаточная функция базового блока В (Вычисление путем применения явных формул).

## Постановка задачи 
Вычисление передаточной функции по явным формулам.

## Команда — исполнитель
kt 

## Зависимости
Зависит от:
- Трехадресный код
- Данная задача зависит от задачи генерации базовых блоков.

## Теория
Определение `d` достигает точки p, если существует путь от точки, непосредственно следующей за `d`, к точке p, такой, что `d` не уничтожается вдоль этого пути. 
GenB – множество определений, генерируемых и не переопределённых базовым блоком B.
KillB – множество остальных определений переменных, определяемых в определениях genB, в других базовых блоках.
Анализ присваиваний должен быть консервативным, то есть если неизвестно, существует ли другое присваивание на пути, то алгоритм должен считать что оно существует.

## Реализация

```csharp
public class TFByCommonWay : ITransmissionFunction<TacNode>
    {
        private ThreeAddressCode basicBlock;
        private Dictionary<ThreeAddressCode, IExpressionSetsContainer> lineGenKill;

        public TFByCommonWay(Dictionary<ThreeAddressCode, IExpressionSetsContainer> LineGenKill)
        {
            lineGenKill = LineGenKill;
        }

        public HashSet<TacNode> Calculate(HashSet<TacNode> _in, ThreeAddressCode bblock)
        {
            basicBlock = bblock;
            var genBlock = new HashSet<TacNode>();
            var killBlock = new HashSet<TacNode>();

            var lines = new List<TacNode>();
            var n = GetBasicBlock().TACodeLines.Count - 1;

            //подсчет kill по формуле killB = kill1 + kill2 + ... + killN
            foreach (var line in GetBasicBlock())
            {
                lines.Add(line);
                killBlock.UnionWith(GetLineKill(line));
            }

            //подсчет gen по формуле genB = gen(n - i) - kill(n - i + 1) - ... - kill(n)
            genBlock.UnionWith(GetLineGen(lines[n])); //gen(n)

            for (int i = n - 1;  i >= 0; i--)
            {
                var tGen = new HashSet<TacNode>();
                tGen.UnionWith(GetLineGen(lines[i]));//gen(n - i)

                for(int j = i + 1; j < n; j++)
                {
                    tGen.ExceptWith(GetLineKill(lines[j]));//kill(n - i + j)
                }
            }


            var exceptX = _in;
            exceptX.ExceptWith(killBlock);
            genBlock.UnionWith(exceptX);

            return genBlock;
        }

        public ThreeAddressCode GetBasicBlock()
        {
            return basicBlock;
        }

        public HashSet<TacNode> GetLineGen(TacNode tacNode)
        {
            return lineGenKill[basicBlock].GetFirstSet();
        }

        public HashSet<TacNode> GetLineKill(TacNode tacNode)
        {
            return lineGenKill[basicBlock].GetSecondSet();
        }
    }
```

## Тесты
Входные блоки:
```
B1:
    i=m-1
    j=n
    a=u1
B2:
    i=i+1
    j=j-1
B3:
    a=u2
B4:
    i=u3
```
Сгенерированные genB и killB:
```
B1 gen:
    i=m-1
    j=n
    a=u1
B1 kill:
    i=i+1
    j=j-1
    a=u2
    i=u3
B2 gen:
    i=i+1
    j=j-1
B2 kill:
    i=m-1
    j=n
    i=u3
B3 gen:
    a=u2
B3 kill:
    a=u1
B4 gen:
    i=u3
B4 kill:
    i=m-1
    i=i+1
```

Входные блоки:
```
B1:
    a=b-2
    c=d+1
B2:
    c=a-1
B3:
    a=d+3
B4:
    b=i
```
Сгенерированные genB и killB:
```
B1 gen:
    a=b-2
    c=d+1
B1 kill:
    c=a-1
    a=d+3
B2 gen:
    c=a-1
B2 kill:
    c=d+1
B3 gen:
    a=d+3
B3 kill:
    a=b-2
B4 gen:
    b=i
B4 kill:

```

## Вывод
Используя методы, описанные выше, мы смогли выполнить задачу. 

