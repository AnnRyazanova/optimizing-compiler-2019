# Протяжка const на основе итеративного алгоритма для достигающих определений

## Постановка задачи

Реализовать протяжку констант на основе информации о достигающих определениях, полученной с помощью итеративного алгоритма.

## Команда — исполнитель
AW

## Зависимости

Зависит от:

- Построение графа потока управления (Null)
- Итеративный алгоритм для достигающих определений (Null)
- Хранение множеств IN/OUT (AW)

От задачи зависят:

- От задачи не исходят зависимости

## Теория

Протяжка констант &mdash; это одна из важнейших задач в разработке оптимизирующих компиляторов. Она определяется как подстановка вычисленной константы, находящейся в правой части генератора переменной, вместо использований данной переменной всюду в коде программы. 

Одним из осложнений подобного глобального преобразования является неизвестность того факта, что данный генератор достигает данного использования по всем веткам выполнения программы, а не переопределяется в ходе движения по некоторым из них.

Для этого нам необходимо рассмотреть множества IN/OUT для достигающих определений (см. задачу о реализации итеративного алгоритма для достигающих определений), которые строятся для каждого базового блока - вершины графа потока управления.

В данном контексте множество IN_B &mdash; это множество переменных, достигающих начало блока B, а OUT_B &mdash; достигающих его конца. 

Таким образом, если проверить, что все определения, достигающие использования переменной (множество IN_B, для базового блока B), являются константами, равны между собой и мы не встретили переопределение данной переменной ранее в блоке, то это использование является константой и его можно заменить на значение достигающего определения.  

## Реализация

Для реализации был написан класс, который реализует интерфейс `IIterativeAlgorithmOptimizer<TacNode>`. 

Он содержит методы:

- Проверка достигающих оператора определений и возвращение строки трехадресного кода, являющейся генератором константы, либо `null` в случае, когда мы не встретили ее определения либо протяжка невозможна
```csharp
 private static TacAssignmentNode Routine(HashSet<TacNode> inData, string operand)
{
    var reachedDefinitions = new HashSet<TacNode>();
    // Проход по всем записям в множестве IN для текущего блока
    foreach (var entry in inData)
    {
        // Если строка не является оператором присваивания - пропускаем ее анализ
        if (!(entry is TacAssignmentNode assignmentEntry)) continue;
        // Если имя переменной найденного оператора присваивания совпадает с
        // ее использованием (operand) и оно является определением константы
        if (assignmentEntry.LeftPartIdentifier == operand &&
            assignmentEntry.SecondOperand == null &&
            Utility.Utility.IsNum(assignmentEntry.FirstOperand))
        {
            // Добавляем оператор присваивания в множество достигающих определений этой константы
            reachedDefinitions.Add(assignmentEntry);
        }
    }
    // Слуйчай, если не нашли генератора константы
    if (reachedDefinitions.Count == 0) return null;

    var tmpValue = (reachedDefinitions.First() as TacAssignmentNode);
    // Если нашли единственное определение, либо все найденные определения равны
    // Возвращаем найденный оператор присваивания, в котором определяется константа
    if (reachedDefinitions.Count == 1 || reachedDefinitions.All(entry =>
            tmpValue != null && (entry as TacAssignmentNode)?.FirstOperand == tmpValue.FirstOperand))
    {
        return tmpValue;
    }

    return null;
}
```

- Выполнения оптимизации
```csharp
//
// Определения необходимых внутри оптимизации переменных
// ...

// Цикл по всем вершинам CFG
foreach (var basicBlock in ita.controlFlowGraph.SourceBasicBlocks)
{
    // Цикл по всем строкам базового блока
    foreach (var line in basicBlock)
    {
        if (!(line is TacAssignmentNode assignmentNode)) continue;
        // Добавление оператора в множество просмотренных
        traversedNodesInBlock.Add(assignmentNode);

        var firstOperand = assignmentNode.FirstOperand;
        var secondOperand = assignmentNode.SecondOperand;
        // Если присутствует первый операнд
        if (firstOperand != null)
        {
            // Находим определение константы, достигнутое использованием FirstOperand
            var tmpValue = Routine(inData, outData, firstOperand);
            if (tmpValue != null) // Если нашли определение и оно -- определение константы
            {
                // Проверка того, что не произошло переопределения строками ранее в блоке
                var encounteredRedefinition = traversedNodesInBlock.FirstOrDefault(entry =>
                                                    string.Equals(tmpValue.LeftPartIdentifier,
                                                        entry.LeftPartIdentifier)) != null;
                // Проверка того, что это первый блок. 
                // В таком случае нам необходимо переопределение строками ранее, так как IN_0 пуст
                if (isFirstBlock) 
                {
                    if (!encounteredRedefinition) continue;
                }
                else
                {
                    if (encounteredRedefinition) continue;
                }
                // Протягиваем константу в рассматриваемый операнд
                assignmentNode.FirstOperand = tmpValue.FirstOperand;
                wasApplied = true;
            }
        }
        // Аналогично для второго операнда выражения -- SecondOperand
        ...
    }
    ...
}
```
## Тесты
### Input
#### Трехадресный код
```
a = 42
c = 100
t1 = a + 1
tmp = t1
t2 = 1 + a
t3 = t2 > 50
if t3 goto L1
goto L2
L1: t4 = 100 * c
b = t4
L2: i = 0
L3: tmp = a
a = 10
i = i + 1
t5 = i < 100
if t5 goto L3
```
#### Вершины CFG (базовые блоки)
```
#0:
a = 42
c = 100
t1 = a + 1
tmp = t1
t2 = 1 + a
t3 = t2 > 50
if t3 goto L1

#1:
goto L2

#2:
L1: t4 = 100 * c
b = t4

#3:
L2: i = 0

#4:
L3: tmp = a
a = 10
i = i + 1
t5 = i < 100
if t5 goto L3
```

### Output
#### Значения множеств IN/OUT
```
--- IN 0 :
null
--- OUT 0:
0)a = 42
1)c = 100
2)t1 = a + 1
3)tmp = t1
4)t2 = 1 + a
5)t3 = t2 > 50

--- IN 1 :
0)a = 42
1)c = 100
2)t1 = a + 1
3)tmp = t1
4)t2 = 1 + a
5)t3 = t2 > 50

--- OUT 1:
0)a = 42
1)c = 100
2)t1 = a + 1
3)tmp = t1
4)t2 = 1 + a
5)t3 = t2 > 50

--- IN 2 :
0)a = 42
1)c = 100
2)t1 = a + 1
3)tmp = t1
4)t2 = 1 + a
5)t3 = t2 > 50

--- OUT 2:
0)L1: t4 = 100 * c
1)b = t4
2)a = 42
3)c = 100
4)t1 = a + 1
5)tmp = t1
6)t2 = 1 + a
7)t3 = t2 > 50

--- IN 3 :
0)a = 42
1)c = 100
2)t1 = a + 1
3)tmp = t1
4)t2 = 1 + a
5)t3 = t2 > 50
6)L1: t4 = 100 * c
7)b = t4

--- OUT 3:
0)L2: i = 0
1)a = 42
2)c = 100
3)t1 = a + 1
4)tmp = t1
5)t2 = 1 + a
6)t3 = t2 > 50
7)L1: t4 = 100 * c
8)b = t4

--- IN 4 :
0)L2: i = 0
1)a = 42
2)c = 100
3)t1 = a + 1
4)tmp = t1
5)t2 = 1 + a
6)t3 = t2 > 50
7)L1: t4 = 100 * c
8)b = t4
9)L3: tmp = a
10)a = 10
11)i = i + 1
12)t5 = i < 100

--- OUT 4:
0)L3: tmp = a
1)a = 10
2)i = i + 1
3)t5 = i < 100
4)c = 100
5)t1 = a + 1
6)t2 = 1 + a
7)t3 = t2 > 50
8)L1: t4 = 100 * c
9)b = t4
```

#### Трехадресный код
```
a = 42
c = 100
t1 = 42 + 1
tmp = t1
t2 = 1 + 42
t3 = t2 > 50
if t3 goto L1
goto L2
L1: t4 = 100 * 100
b = t4
L2: i = 0
L3: tmp = a
a = 10
i = i + 1
t5 = i < 100
if t5 goto L3

```
## Вывод

Был реализован класс для проведения глобальной протяжки констант на основе информации о достигающих определениях, полученных с помощью итеративного алгоритма.

Его работоспособнасть была успешно протестирована. 
