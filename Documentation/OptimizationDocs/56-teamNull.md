# Название задачи
Ускорение итерационного алгоритма для задачи о достигающих определениях засчет перенумерации базовых блоков

## Постановка задачи
Создать класс, реализующий ускорение итерационного алгоритма для 
задачи о достигающих определениях засчет перенумерации базовых блоков.

## Команда — исполнитель
Null

## Зависимости
Зависит от:
- DST
- Обобщенный итерационный алгоритм (ЗГ)
- Построение глубинного остовного дерева с соответствующей нумерацией вершин (Null)

## Теория

Верхняя граница количества итераций
равна количеству узлов в графе потока
управления, т.к. если определение
достигает некоторой точки, то оно может
сделать это по пути без циклов
При правильной нумерации базовых
блоков на реальных программах
количество итераций <= 5

## Реализация
```csharp
public class ReachingDefinitionsSortedITA : IterationAlgorithm<TacNode>
{
	public ReachingDefinitionsSortedITA(
			ControlFlowGraph cfg,
            Dictionary<ThreeAddressCode, IExpressionSetsContainer> lines
        ) : base(cfg.GetCFGWithSortedVertices(), new TFByComposition(lines), new UnionCollectionOperator<TacNode>())
	{
		Execute();
	}
}
```
## Тесты

INPUT:

```
if (a < 5)
     for (j = 1 to 10)
         a = a + 1;
 else
     if (a > 10)
         a = a - 10;
p = 2
```

OUTPUT:

```
	#0
0.0: t1 = a < 5
     if t1 goto L1

	#1
1.0 t2 = a > 10
    if t2 goto L3

	#2
goto L4

	#3
3.0: L3: t3 - 10
3.1: a = t3

	#4
L4: goto L2

	#5
5.0: L1: j = 1

	#6
6.0: L5: t4 = a + 1
6.1: a = t4
6.2: j = j+1
6.3: t5= j < 10
     if t5 goto L5

	#7
7.0: L2: p=2

Gen/Kill

Gen[0] = {0.0}
Kill[0] = {}

Gen[1] = {1.0}
Kill[1] = {}

Gen[2] = {}
Kill[2] = {}

Gen[3] = {3.0, 3.1}
Kill[3] = {6.1}

Gen[4] = {}
Kill[4] = {}

Gen[5] = {5.0}
Kill[5] = {6.2}

Gen[6] = {6.0, 6.1, 6.2, 6.3}
Kill[6] = {3.1, 5.0}

Gen[7] = {7.0}
Kill[7] = {}

IN/OUT

OUT[0] = {0.0}

IN[1] = {0.0}
OUT[1] = {0.0, 1.0}

IN[2] = {0.0, 1.0}
OUT[2] = {0.0, 1.0}

IN[3] = {0.0, 1.0}
OUT[3] = {0.0, 1.0, 3.0, 3.1}

IN[4] = {0.0, 1.0, 3.0, 3.1}
OUT[4] = {0.0, 1.0, 3.0, 3.1}

IN[5] = {0.0}
OUT[5] = {0.0, 5.0}

IN[6] = {0.0, 5.0, 6.0, 6.1, 6.2, 6.3}
OUT[6] = {0.0, 6.0, 6.1, 6.2, 6.3}

IN[7] = {0.0, 1.0, 3.0, 3.1, 6.0, 6.1, 6.2, 6.3}
OUT[7] = {0.0, 1.0, 3.0, 3.1, 6.0, 6.1, 6.2, 6.3, 7.0}
```
![](../images/55-teamNull-1.png)

## Вывод
Используя метод, описанные выше, мы смогли выполнить ускорение итерационного алгоритма для задачи о достигающих определениях засчет перенумерации базовых блоков
