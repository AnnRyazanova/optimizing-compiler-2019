# Парсер языка и построение AST-дерева
## Постановка задачи
Написать парсер языка на языке C# с использованием GPLex и Yacc. Реализовать построение синтаксического дерева программы.

## Команда — исполнитель
M&M

## Зависимости
&mdash;

## Теория
Для решения данной задачи необходимо реализовать две составляющие: лексер и парсер языка.  **Опр.** Лексический анализатор (лексер) — это программа или часть программы, выполняющая лексический анализ. Лексер предназначен для разбиения входного потока символов на лексемы - отдельные, осмысленные единицы программы.

Основные задачи, которые выполняет лексер:

-   Выделение идентификаторов и целых чисел
-   Выделение ключевых слов
-   Выделение символьных токенов

**Опр.**  Парсер (или синтаксический анализатор) — часть программы, преобразующей входные данные (как правило, текст) в структурированный формат. Парсер выполняет синтаксический анализ текста. Парсер принимает на вход поток лексем и формирует абстрактное синтаксическое дерево (AST).
## Реализация
Для автоматического создания парсера создаются файлы SimpleLex.lex (описание лексического анализатора) и SimpleYacc.y (описание синтаксического анализатора). Код лексического и синтаксического анализаторов создаются на C# запуском командного файла generateParserScanner.bat.

Синтаксически управляемая трансляция состоит в том, что при разборе текста программы на каждое распознанное правило грамматики выполняется некоторое действие. Данные действия придают смысл трансляции (переводу) и поэтому мы называем их семантическими. Семантические действия записываются в .y-файле после правил в фигурных скобках и представляют собой код программы на C# (целевом языке компилятора).

Как правило, при трансляции программа переводится в другую форму, более приспособленную для анализа, дальнейших преобразований и генерации кода.

Мы будем переводить текст программы в так называемое синтаксическое дерево. Если синтаксическое дерево построено, то программа синтаксически правильная, и ее можно подвергать дальнейшей обработке.

В синтаксическое дерево включаются узлы, соответствующие всем синтаксическим конструкциям языка. Атрибутами этих узлов являются их существенные характеристики. Например, для узла оператора присваивания AssignNode такими атрибутами являются IdNode - идентификатор в левой части оператора присваивания и ExprNode - выражение в правой части оператора присваивания.
#### Парсер языка
Парсер был реализован для языка со следующим синтаксисом:
```csharp
a = 777; // оператор присваивания
```
```csharp
// пример арифметических операций
a = a - b;
c = a + b;
a = a * 3;
a = 5 * b;
```
```csharp
// пример операторов сравнения
c = a < b;
c = a > b;
c = a == b;
a = 5 * b;
// логическое "нет"
c = !a;
```
```csharp
// полная форма условного оператора
if (a < b)    
	a = 555;
else
{
    b = 666;
    с = 777;
}
// сокращенная форма условного оператора 
if (b == c)    
	c = 666;
```
```csharp
// операторы циклов
// цикл while
while(a < b)
{
    ...
}
// цикл for
for(i = 0 to 10)
{    
	...
}
```

```csharp
// оператор goto
goto l 7:
// переход по метке
l 7:
```
Для создания парсера использовались Yacc и GPLex, были созданы соответствующие файлы .y и .lex.  
Пример содержимого .y файла:
```
%token <iVal> INUM
%token <dVal> RNUM
%token <sVal> ID

%type <eVal> expr ident T F S
%type <stVal> statement assign block
 empty while for if println
 idenlist label goto
%type <blVal> stlist block

%%
progr : stlist { root = $1; }
	  ;
statement: assign SEMICOLON { $$ = $1; }
		| block { $$ = $1; }
		| empty SEMICOLON  { $$ = $1; }
		| while { $$ = $1; }
		| for { $$ = $1; }
		| if { $$ = $1; }
		| label { $$ = $1; }
		| goto { $$ = $1; }
		| idenlist SEMICOLON { $$ = $1;}
		;
```
Пример содержимого .lex файла:
```
{REALNUM} {
	yylval.dVal = double.Parse(yytext);
	return (int)Tokens.RNUM;
}
{ID}  {
	int res = ScannerHelper.GetIDToken(yytext);
	if (res == (int)Tokens.ID)
		yylval.sVal = yytext;
	return res;
}
"=" { return (int)Tokens.ASSIGN; }
";" { return (int)Tokens.SEMICOLON; }
":" { return (int)Tokens.COLON; }
```
#### Построение AST-дерева

Для построения AST дерева были созданы классы для каждого типа узла:
-   Node.cs - базовый класс для всех узлов
    
-   ExprNode.cs  - базовый класс для выражений
    
-   AssignNode.cs - операция присваивания
    
-   BinOpNode.cs  - класс для бинарных операций
    
-   UnOpNode - класс для унарных операций
    
-   IntNumNode.cs - класс для целочисленных констант
    
-   IdNode.cs - класс для идентификаторов
    
-   StatementNode.cs - базовый класс для всех операторов
    
-   BlockNode.cs  - класс для блока
    
-   WhileNode.cs  - класс для цикла  _while_
    
-   ForNode.cs - класс для цикла  _for_
    
-   GotoNode.cs - класс для  _goto_
    
-   IfNode.cs - класс для оператора сравнения
    
-  LabelNode.cs - класс метки goto
    
-   EmptyNode.cs - класс для пустого узла

Пример кода, описывающего оператор цикла  _while_:
```csharp
public class WhileNode : StatementNode
{
	public ExprNode Expr { get; set; }
	public StatementNode Stat { get; set; }
	public WhileNode(ExprNode expr, StatementNode stat)
	{
		Expr = expr;
		Stat = stat;
	}
	public override void Visit(Visitor v)
	{
		v.VisitWhileNode(this);
	}
	public override string ToString()
	{
		return "while(" + Expr + ")\n" + Stat;
	}
}
```
## Тесты
--

## Вывод
Был реализован парсер языка и построено AST-дерево.

